// Code generated by go-swagger; DO NOT EDIT.

package assettype

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new assettype API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new assettype API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new assettype API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for assettype API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeApplicationMergePatchJSON sets the Content-Type header to "application/merge-patch+json".
func WithContentTypeApplicationMergePatchJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/merge-patch+json"}
}

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationHalJSON sets the Accept header to "application/hal+json".
func WithAcceptApplicationHalJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/hal+json"}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptApplicationVndErrorJSON sets the Accept header to "application/vnd.error+json".
func WithAcceptApplicationVndErrorJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/vnd.error+json"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteAssetType(params *DeleteAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAssetTypeNoContent, error)

	DeleteAssetTypeFileAssignment(params *DeleteAssetTypeFileAssignmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAssetTypeFileAssignmentOK, error)

	GetAssetType(params *GetAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAssetTypeOK, error)

	ListAssetTypes(params *ListAssetTypesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAssetTypesOK, error)

	SaveAssetType(params *SaveAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SaveAssetTypeOK, *SaveAssetTypeCreated, error)

	SaveAssetTypeFileAssignment(params *SaveAssetTypeFileAssignmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SaveAssetTypeFileAssignmentOK, error)

	UpdateAssetType(params *UpdateAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAssetTypeOK, error)

	UpdateAssetTypeVariable(params *UpdateAssetTypeVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAssetTypeVariableNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DeleteAssetType deletes an asset type

Deletes an asset type. Deletion only possible when the type has no child-type and there is no asset that instantiate it.
*/
func (a *Client) DeleteAssetType(params *DeleteAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAssetTypeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAssetTypeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteAssetType",
		Method:             "DELETE",
		PathPattern:        "/assettypes/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteAssetTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteAssetTypeNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteAssetType: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteAssetTypeFileAssignment deletes a file assignment from an asset type

Deletes a file assignment from an asset type. If the type's parent has defined a file with the same key, the key will be displayed with the inherited value.
*/
func (a *Client) DeleteAssetTypeFileAssignment(params *DeleteAssetTypeFileAssignmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAssetTypeFileAssignmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAssetTypeFileAssignmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteAssetTypeFileAssignment",
		Method:             "DELETE",
		PathPattern:        "/assettypes/{id}/fileAssignments/{key}",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteAssetTypeFileAssignmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteAssetTypeFileAssignmentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteAssetTypeFileAssignment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAssetType reads an asset type

Read an asset type
*/
func (a *Client) GetAssetType(params *GetAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAssetTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAssetTypeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAssetType",
		Method:             "GET",
		PathPattern:        "/assettypes/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAssetTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAssetTypeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAssetType: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListAssetTypes lists all asset types

List all asset types
*/
func (a *Client) ListAssetTypes(params *ListAssetTypesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAssetTypesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAssetTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listAssetTypes",
		Method:             "GET",
		PathPattern:        "/assettypes",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAssetTypesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListAssetTypesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listAssetTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	 SaveAssetType creates or update an asset type

	 Create or Update an asset type. Complete asset type model payload should be provided in request.

	<b> Following are the updates allowed</b>

* Asset type description can be updated.
* Asset type variable's can be created, updated and removed. Varaible length, default Value and Unit can be changed. The unit changes from the API does not compute any value changes derived after the unit changes, the values will remain as it is and only the unit will be updated. The length can only be increased of a string variable and it cannot be decreased.
* File assignments can be updated and removed.

* Aspects can be created, updated and removed, please refer sample payloads below

  - Create aspect
    {
    "name": "leftWing",
    "aspectTypeId": "mdsp.wing"
    }
  - Update aspect <b><u>aspectId should be provided in payload</u></b> (only name can be updated)
    {
    "name": "rightWing",
    "aspectId": "b9cbfc7073be4530887cdb1e71c932b8",
    "aspectTypeId": "mdsp.wing"
    }
  - To delete an aspect, aspect should not be part of aspects payload
*/
func (a *Client) SaveAssetType(params *SaveAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SaveAssetTypeOK, *SaveAssetTypeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSaveAssetTypeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "saveAssetType",
		Method:             "PUT",
		PathPattern:        "/assettypes/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SaveAssetTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *SaveAssetTypeOK:
		return value, nil, nil
	case *SaveAssetTypeCreated:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for assettype: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SaveAssetTypeFileAssignment adds a new file assignment to an asset type

Add a new file assignment to a given asset type. All asset which extends these types will have its file by default.
*/
func (a *Client) SaveAssetTypeFileAssignment(params *SaveAssetTypeFileAssignmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SaveAssetTypeFileAssignmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSaveAssetTypeFileAssignmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "saveAssetTypeFileAssignment",
		Method:             "PUT",
		PathPattern:        "/assettypes/{id}/fileAssignments/{key}",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SaveAssetTypeFileAssignmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SaveAssetTypeFileAssignmentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for saveAssetTypeFileAssignment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	UpdateAssetType patches an asset type

	Patch an asset type. Conforms to RFC 7396 - JSON merge Patch.

<b> Following are the updates allowed</b>
* Asset type description can be updated.
* Asset type variable's can be created, updated and removed. Varaible length, default Value and Unit can be changed. The unit changes from the API does not compute any value changes derived after the unit changes, the values will remain as it is and only the unit will be updated. The length can only be increased of a string variable and it cannot be decreased.
* File assignments can be updated and removed.

* Aspects can be created, updated and removed, please refer sample payloads below

  - Create aspect
    {
    "name": "leftWing",
    "aspectTypeId": "mdsp.wing"
    }
  - Update aspect, <b><u>aspectId should be provided in payload</u></b> (only name can be updated)
    {
    "name": "rightWing",
    "aspectId": "b9cbfc7073be4530887cdb1e71c932b8",
    "aspectTypeId": "mdsp.wing"
    }
  - To delete an aspect, aspect should not be part of aspects payload
*/
func (a *Client) UpdateAssetType(params *UpdateAssetTypeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAssetTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAssetTypeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateAssetType",
		Method:             "PATCH",
		PathPattern:        "/assettypes/{id}",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/merge-patch+json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAssetTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAssetTypeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateAssetType: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateAssetTypeVariable updates variables from an asset type

Updates an existing variable defined on an asset type. Variables cannot be added or deleted using this operation, for adding or deleting variables use patch/put assettype api. Any variable which is not part of the request will remain unchanged. Variable's Name, Length, Default Value and Unit can be changed. The unit changes from the api does not compute any value changes derived after the unit changes, the values will remain as it is and only the unit will be updated. The length can only be increased of a string variable and it cannot be decreased. This operation will increment the asset type etag value.
*/
func (a *Client) UpdateAssetTypeVariable(params *UpdateAssetTypeVariableParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAssetTypeVariableNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAssetTypeVariableParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateAssetTypeVariable",
		Method:             "PATCH",
		PathPattern:        "/assettypes/{id}/variables",
		ProducesMediaTypes: []string{"application/hal+json", "application/vnd.error+json"},
		ConsumesMediaTypes: []string{"application/merge-patch+json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAssetTypeVariableReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAssetTypeVariableNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateAssetTypeVariable: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
